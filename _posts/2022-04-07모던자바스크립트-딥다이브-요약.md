---
layout: post
title: 모던자바스크립트 딥다이브 요약
date: 2022-04-07 09:00:50 +0900
categories: Notes-모던자바스크립트 딥다이브
tags: Notes JavaScript book deep dive
---

## 1. 프로그래밍

#### 1.1 프로그래밍이란?

프로그래밍이란 컴퓨터에게 실행을 요구하는 일종의 커뮤니케이션이다. 커뮤니케이션에 가장 먼저 필요한 것은 무엇을, 어떻게 실행하고 싶은지를 명확히 정의내리는 것이다.

이 과정에서 필요한 것이 **문제해결능력**이다. 복잡함을 단순하게 분해하고 자료를 정리하고 구분해야하며, 순서에 맞게 행위를 배열해야 한다.

문제해결방안을 고려할 때 요구되는 것이 **컴퓨팅 사고**이다. 

#### 1.2 프로그래밍 언어

정의된 문제 해결 방안은 컴퓨터에게 전달되어야 한다. 컴퓨터가 이해할 수 있도록 이는 기계어로 전달되어야 한다. 그러나 기계어는 인간이 이해하기 매우 복잡하기 때문에 대안으로 약속된 구문(Syntax,문법)으로 구성된 프로그래밍 언어를 사용해 프로그램을 작성한뒤 기계어로 번역하는 일련의 과정을 거친다. 이 때 사용되는 것이 컴파일러 혹은 인터프리터이다. 

프로그래밍은 구문(syntax)과 의미(semantics)의 조합으로 표현된다.

#### 1.3 구문과 의미

프로그래밍 학습은 언어를 학습하는 것에서 시작된다. 여느 언어가 다 그렇듯, 소통을 위해서는 문법과 의미 모두가 중요하다. 프로그래밍에서 의미란, **문제가 해결되는 것**을 의미한다. 

대부분의 프로그래밍 언어는 "변수와 값(variable, value)", "키워드", "연산자", "표현식과 문", "조건문"과 "반복문"에 의한 "흐름제어", "함수" 그리고 자료구조인 "객체", "배열"등과 같은 문법을 제공한다.

변수를 통해 값을 저장하고 참조하며 연산자로 값을 연산, 평가하고 조건문과 반복문에 의한 흐름제어로 코드의 실행 순서를 제어하고 함수로 재사용 가능한 문의 집합을 만들며 객체, 배열 등으로 자료를 구조화한다.

요구사항의 집합을 분석해서 적절한 자료구조와 함수의 집합으로 변환한 후, 그 흐름을 제어하는 것이다.





## 2.자바스크립트란?



(생략)



#### 2.3.5 SPA프레임워크

개발 규모와 복잡도가 상승하면서 이를 위해 패턴과 라이브러리가 대거 출현했다. 그러나 변경에 유연하면서 확장하기 쉬운 애플리케이션 아키텍처의 구축이 어려워지면서 프레임워크가 등장한다.

CBD(component based development)방법론을 기반으로 하는 SPA(single page application)가 대중화되면서 다양한 SPA 프레임워크/라이브러리가 많은 사용층을 확보중이다.

> SPA의 예: Angular, React, Vue.js, Svelte



#### 2.4 자바스크립트와 ECMAScript



ECMAScript는 자바스크립트의 포준 사양인 ECMA-262를 말하며  프로그래밍 언어의 핵심 문법을 규정한다. 각 브라우저 제조사는 ECMAScript 사양을 준수해서 브라우저에 내장되는 자바스크립트 엔진을 구현한다.

자바스크립트는 기본뼈대인 ECMAScript와 브라우저가 별도로 지원하는 클라이언트 사이드 Web API, 즉 DOM, BOM, Canvas, XMLHttpRequest, fetch, requestAnimationFrame, SVG, Web Storage, Web Component, Web Worker 등을 아우르는 개념이다.

클라이언트 사이드 Web API는 월드 와이드 웹 콘소시엄에서 별도의 사양으로 관리하고 있다. [링크](https://developer.mozilla.org/ko/docs/Web/API)

#### 2.5 자바스크립트의 특징

자바스크립트는 웹 브라우저에서 동작하는 유일한 프로그래밍언어로, 기본 문법은 C, 자바와 유사하고 Self에서는 프로토타입 기반 상속을, Scheme에서는 함수의 개념을 차용했다.

자바스크립트는 인터프리터 언어다.

---

##### 인터프리터 언어 vs 컴파일러 언어

|                     컴파일러 언어                     |                       인터프리터 언어                        |
| :---------------------------------------------------: | :----------------------------------------------------------: |
| 컴파일 타임에 소스코드 전체를 머신코드로 변환 후 실행 | 런타임에 문 단위로 한 줄씩 중간 코드인 바이트코드로 변환 후 실행 |
|                    실행 파일 생성                     |                     실행 파일 생성 안함                      |
|        펌파일 단계와 실행 단계가 분리되어있음         |           한줄씩 바이트코드로 변환하고 바로 실행함           |
|               컴파일은 단 한번 수행된다               |                   실행될 때마다 인터프리트                   |
|     컴파일과 실행단계가 분리되어 실행 속도가 빠름     |        인터프리트와 실행이 반복수행되므로 비교적 느림        |

그러나 대부분의 모던 브라우저에서는 명시적인 컴파일 단계를 거치지는 않지만 복잡한 과정을 거치며 일부 소스코드를 컴파일하고 실행한다. 그러나 인터프리터의 도움없이 실행이 안되므로 컴파일러 언어는 아니다.

자바스크립트는 명령형, 함수형, 프로토타입 기반 객체지향 프로그래밍을 지원하는 **멀티 패러다임 프로그래밍 언어**다.

클래스, 상속, 정보 은닉을 위한 키워드가 없어서 객체지향 언어가 아니라는 논쟁이 있지만 자바스크립트는 클래스 기반 객체지향 언어보다 효율적이면서 강력한 프로토타입 기반의 객체지향 언어다.



### 4.변수

컴퓨터는  CPU를 사용해 연산하고, 메모리를 사용해 데이터를 기억한다.

메모리는 데이터를 저장할 수 있는 메모리 셀의 집합체다. 메모리 셀 하나의 크기는 1바이트(8비트)이며, 컴퓨터는 메모리 셀의 크기, 즉 1바이트 단위로 데이터를 저장하거나 읽어들인다.

각 셀은 고유의 메모리 주소를 갖는다. 이 메모리 주소는 메모리 공간의 위치를 나타내며, 0부터 시작해 메모리의 크기만큼 정수로 표현된다.

```js
10 + 20
```

위의 연산을 한다고 가정해보자. 

연산이 끝나면 연산 결과는 메모리에 저장되지만 그 결과를 재사용할 수 없는 상태이다. 결과가 저장된 메모리에 직접 접근하는 수밖에 없다. 하지만 메모리 주소를 통해 값에 직접 접근하는 것은 치명적인 오류를 발생시킬 수 있어 자바스크립트는 직접적인 메모리 제어를 허용하지 않는다. 

게다가 값이 저장될 때마다 메모리의 상황에 따라서 임의의 주소에 저장이 되니 주소를 알 수도 없다.

그래서 **변수**라는 걸 활용한다. 변수는 하나의 값을 저장하기 위해 확보한 모모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름을 말한다. **값의 위치를 가리키는 상징적인 이름**이다. 이를 통해 개발자는 안전히 값에 접근할 수 있다.

``` js
const result = 10 + 20;
```

메모리 공간에 저장된 값을 식별할 수 있는 고유한 이름을 **변수이름**(변수명) 이라고 한다. 그리고 변수에 저장된 값을 **변수 값**이라고 한다. 변수에 값을 대입하는 것을 **할당**(대입, 저장, assignment)이라 하고 변수에 저장된 값을 읽어들이는 것을 **참조**(reference)라고 한다.

#### 4.2 식별자

변수 이름을 **식별자**(identifier)라고도 한다. **어떤 값을 구별해서 식별할 수 있는 고유한 이름**이라는 뜻이다.

식별자는 값이 저장되어 있는 메모리 주소와 매핑 관계를 맺으며, 이 매핑 정보도 메모리에 저장된다. 즉 **식별자는 값이 아니라 메모리 주소를 기억하고 있다.**

식별자라는 용어는 변수 이름에만 국한되어 사용되는 것이 아니라, 변수, 함수, 클래스 등의 이름들은 모두 식별자다. **메모리 상에 존재하는 어떤 값을 식별할 수 있는 이름은 모두 식별자라고 부르는 것**이다.

#### 4.3 변수선언

변수 선언(variation declaration)이란 변수를 생성하는 것을 말한다. 값을 저장키 위한 메모리 공간은 확보(allocate)하고 변수 이름과 확보된 메모리 공간은 화보가 해제(release)되기 전까지는 누구도 확보된 메모리 공간을 사용할 수 없도록 보호되므로 안전히 사용할 수 있다.

변수 선언에는 `var`,`const`,`let` 키워드를 사용한다. 

- 키워드: 자바스크립트 엔진이 수행할 동작을 규정한 일종의 명령어다.

> `var` 의 단점 : 블록 레벨 스코프를 지원하지 않고 함수 레벨 스코프를 지원한다는 것이다. 이로 인해 의도치 않게 전역 변수가 선언되어 부작용이 생기기도 한다.



자바스크립트 엔진은 변수 선언을 다음과 같은 2단계에 거쳐 수행한다.

1. 선언단계: 변수명을 등록해서 자바스크립트 엔진에 변수의 존재를 알림.
2. 초기화단계: 메모리 공간을 확보하고 암묵적으로 undefined를 할당해 초기화한다.

- undefined: 자바스크립트에서 제공하는 원시타입의 값

  

> 변수 이름을 비롯한 모든 식별자는 실행 컨텍스트에 등록된다. 실행 컨텍스트(execution context)는 자바스크립트 엔진이 소스코드를 평가하고 실행하기 위해 필요한 환경을 제공하고 코드의 실행 결과를 실제로 관리하는 영역이다.



초기화(initialization)란 변수가 선언된 이후 최초로 값을 할당하는 것을 말한다. 만약 초기화 단계를 거치지 않으면 확보된 메모리 공간에는 이전에 다른 애플리케이션이 사용했던 값이 남아있을 수 있다. 이를 쓰레기 값(garbage value)이라 한다. 따라서 메모리 공간을 확보한 다음, 값을 할당하지 않은 상태에서 곧바로 변수 값을 참조하면 쓰레기 값이 나올 수 있지만 자바스크립트의  `var` 키워드는 암묵적으로 초기화를 수행하므로 이런 위험으로부터 안전하다.



만일 선언하지 않은 식별자에 접근하면 ReferenceError(참조 에러)가 발생한다. 



#### 4.4 변수 선언의 실행 시점과 변수 호이스팅

변수 선언문이 변수를 참조하는 코드보다 뒤에 있어도, 자바스크립트 코드가 실행되면 해당 변수의 참조 에러가 발생하지 않는다. 대신 참조된 변수값은 undefined이다.

원인은 자바스크립트 엔진의 작동 방식에 있다. 자바스크립트 엔진은 런타임 이전 소스코드의 평가 과정에서 모든 선언문을 먼저 실행한다. 이후 평가가 끝나고 나서야 선언문을 제외한 모든 소스코드를 한 줄씩 순차적으로 실행한다.

이처럼 변수 선언문이 코드의 선두로 `끌어 올려진 것`처럼 동작하는 자바스크립트 고유의 특징을 **변수 호이스팅**이라고 한다.



#### 4.5 값의 할당

변수에 값을 할당(대입, 저장, assignment) 할 때는 할당 연산자 `=` 를 사용한다. 우변의 값을 좌변의 변수에 할당한다.

```js
var score;// 변수의 선언
score = 80;// 값의 할당
```

대부분 이를 아래와 같이 한줄로 단축해서 사용한다.

```js
var score = 80;
```

단축해서 사용해도 자바스크립트 엔진은 해당 문을 2개의 문으로 나누어 각각 실행한다.

주의할 점은 변수 선언과 할당의 실행 시점이 다르다는 것이다. 변수 선언은 런타임 이전에, 값의 할당은 런타임에 실행된다.



#### 4.6 값의 재할당

재할당이란 이미 값이 할당되어 있는 변수에 새로운 값을 다시 할당하는 것을 말한다. `var` 에는 재할당이 가능한데 var키워드로 선언한 변수는 선언과 동시에 undefined로 초기화되기 때문에 엄밀히 말하자면 처음에 할당할 때부터 재할당인 셈이다.

>  재할당이 가능하기 때문에 변수라고 부르는 것이고, 재할당이 되지 않는 것은 상수라고 부른다. 

 

재할당이 되면 원래의 메모리 공간을 지우고 새로 값을 저장하는 것이 아니라, 새로운 메모리 공간을 확보하고 그 메모리 공간에 새 값을 저장한다.

메모리에는 예전에 저장된 값들이 그대로 저장되어 있고, 대신 어떤 식별자와도 매핑되어있지 않다. 이 불필요한 값들은 가비지 콜렉터에 의해서 메모리에서 자동으로 해제된다.



#### 4.7 식별자 네이밍 규칙

예약어는 식별자가 될 수 없다.

변수 선언에 별도의 주석이 필요하다면 변수의 존재목적을 명확히 드러내지 못하는 것이다.

네이밍 컨벤션의 경우 일반적으로 변수나 함수의 이름에는 카멜 케이스를 사용하고, 생성자 함수, 클래스의 이름에는 파스칼 케이스를 사용한다.



## 5장 표현식과 문

#### 5.1 값

값(value)는 식(표현식 expression)이 평가(evaluate)되어 생성된 결과를 말한다. 평가란 식을 해석해서 값을 생성하고나 참조하는 것을 의미한다.

```js
//10 + 20은 평가되어 숫자 값 30을 생성한다.
10 + 20; //30
```

모든 값은 데이터 타입을 가지며 메모리에 비트의 나열로 저장된다. 저장된 값은 데이터 타입에 따라 다르게 해석될 수 있다. 예를 들어 `0100 0001` 을 숫자로 해석하면 `65`, 문자로 해석하면 `A`가 된다.



값은 변수에 할당된다.



```js
//변수에는 10 + 20이 평가되어 생성된 숫자 값 30이 할당된다.
var sum = 10 + 20;
```

`sum` 변수에 할당되는 것은 `10 + 20`이 아니라 `10 + 20`이 평가된 값인 `30` 이다. 따라서 `10 + 20` 은 할당 이전에 평가되어 값을 생성해야 한다.

 값은 다양한 방법으로 생성할 수 있다.



#### 5.2 리터럴

리터럴(literal)은 **사람이 이해할 수 있는 문자 또는 약속된 기호를 사용해 값을 생성하는 표기법**(notation)을 말한다.



```js
//숫자 리터럴 3
3	
```

여기서 3은 단순한 아라비아 숫자가 아닌 숫자 리터럴이다. 사람이 이해할 수 있는 아라비아 숫자를 사용해 숫자 리터럴3을 코드에 기술하면 자바스크립트 엔진은 이를 평가해 숫자 값 3을 생성한다.

자바스크립트 엔진은 런타임에 리터럴을 평가해 값을 생성한다.



| 리터럴                                 | 예시                             | 비고      |
| -------------------------------------- | -------------------------------- | --------- |
| 정수 리터럴(Decimal)                   | 100                              |           |
| 부동소수점 리터럴(Floating number)     | 10.5                             |           |
| 2진수 리터럴(Binary)                   | 0b01000001                       | 0b로 시작 |
| 8진수 리터럴(Octal)                    | 0o101                            | 0o로 시작 |
| 16진수 리터럴(Hexadecimal)             | 0x41                             | 0x로 시작 |
| 문자열 리터럴(String)                  | 'Hello'<br />"World"             |           |
| 불리언 리터럴(Boolean)                 | true<br />false                  |           |
| null 리터럴                            | null                             |           |
| undefined 리터럴                       | undefined                        |           |
| 객체 리터럴(Object)                    | { name: 'Lee', address: 'Seoul'} |           |
| 배열 리터럴(Array)                     | [ 1, 2, 3 ]                      |           |
| 함수 리터럴(Function)                  | function(){}                     |           |
| 정규 표현식 리터럴(Regular expression) | /[A-Z]+/g                        |           |



#### 5.3 표현식

표현식(expression)은 값으로 평가될 수 있는 문(statement)이다. 즉, 표현식이 평가되면 새로운 값을 생성하거나 기존값을 참조한다.

리터럴은 값으로 평가되므로 리터럴도 표현식이다.

변수 식별자를 참조하면 변수값으로 평가된다. 식별자 참조는 값을 생성하지는 않지만 값으로 평가되므로 표현식이다.

즉, **값으로 평가될 수 있는 문은 모두 표현식**이다.

표현식과 값은 동치이며, 표현식을 값처럼 사용할 수 있다. 값이 위치할 수 있는 자리에는 표현식도 위치할 수 있다는 것을 의미한다.



#### 5.4 문

**문(statement)은 프로그램을 구성하는 기본 단위이자 최소 실행 단위**다. 문의 집합이 프로그램이며, 문을 작성하고 나열하는 것이 프로그래밍이다.

문은 여러 토큰으로 구성된다. **토큰(token)이란 문법적인 의미를 가지며, 문법적으로 더 이상 나눌 수 없는 코드의 기본 요소를 의미한다.** 예를 들어 키워드, 식별자, 연산자, 리터럴, 세미콜론이나 마침표 등의 기호들은 모두 토큰이다.

문을 명령문이라고도 부른다.

문은 선언문, 할당문, 조건문, 반복문 등으로 구분할 수 있다. 

#### 5.5 세미콜론과 세미콜론 자동 삽입 기능

세미콜론은 문의 종료를 나타낸다. 코드 블록 뒤에는 세미콜론을 붙이지 않는다. 코드 블록은 자체 종결성을 갖고 있기 때문이다.

세미콜론을 붙이는 것은 옵션이다. 생략이 가능하며 자바스크립트 엔진이 소스코드를 해석할 때 문의 끝이라고 예측되는 지점에 세미콜론을 자동으로 붙여주는 세미콜론 자동 삽입 기능(ASI:automatic semicolon insertion)이 암묵적으로 수행되기 때문이다.



#### 5.6 표현식인 문과 표현식이 아닌 문

값으로 표현될 수 있는 문은 모두 표현식이다.

변수에 할당해 보았을 때, 에러가 나지 않으면 표현식이고, 아니면 표현식이 아닌 것이다.

