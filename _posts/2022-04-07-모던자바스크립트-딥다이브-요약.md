---
layout: post
title: 모던자바스크립트 딥다이브 요약 (미완성)
date: 2022-04-21 09:00:50 +0900
categories: Book-모던자바스크립트 딥다이브
tags: JavaScript BOOK deepdive
---

## 1. 프로그래밍

#### 1.1 프로그래밍이란?

프로그래밍이란 컴퓨터에게 실행을 요구하는 일종의 커뮤니케이션이다. 커뮤니케이션에 가장 먼저 필요한 것은 무엇을, 어떻게 실행하고 싶은지를 명확히 정의내리는 것이다.

이 과정에서 필요한 것이 **문제해결능력**이다. 복잡함을 단순하게 분해하고 자료를 정리하고 구분해야하며, 순서에 맞게 행위를 배열해야 한다.

문제해결방안을 고려할 때 요구되는 것이 **컴퓨팅 사고**이다. 

#### 1.2 프로그래밍 언어

정의된 문제 해결 방안은 컴퓨터에게 전달되어야 한다. 컴퓨터가 이해할 수 있도록 이는 기계어로 전달되어야 한다. 그러나 기계어는 인간이 이해하기 매우 복잡하기 때문에 대안으로 약속된 구문(Syntax,문법)으로 구성된 프로그래밍 언어를 사용해 프로그램을 작성한뒤 기계어로 번역하는 일련의 과정을 거친다. 이 때 사용되는 것이 컴파일러 혹은 인터프리터이다. 

프로그래밍은 구문(syntax)과 의미(semantics)의 조합으로 표현된다.

#### 1.3 구문과 의미

프로그래밍 학습은 언어를 학습하는 것에서 시작된다. 여느 언어가 다 그렇듯, 소통을 위해서는 문법과 의미 모두가 중요하다. 프로그래밍에서 의미란, **문제가 해결되는 것**을 의미한다. 

대부분의 프로그래밍 언어는 "변수와 값(variable, value)", "키워드", "연산자", "표현식과 문", "조건문"과 "반복문"에 의한 "흐름제어", "함수" 그리고 자료구조인 "객체", "배열"등과 같은 문법을 제공한다.

변수를 통해 값을 저장하고 참조하며 연산자로 값을 연산, 평가하고 조건문과 반복문에 의한 흐름제어로 코드의 실행 순서를 제어하고 함수로 재사용 가능한 문의 집합을 만들며 객체, 배열 등으로 자료를 구조화한다.

요구사항의 집합을 분석해서 적절한 자료구조와 함수의 집합으로 변환한 후, 그 흐름을 제어하는 것이다.



## 2.자바스크립트란?



(이미 위키피디아 등에서 많이 읽은 부분이어서 생략함)



#### 2.3.5 SPA프레임워크

개발 규모와 복잡도가 상승하면서 이를 위해 패턴과 라이브러리가 대거 출현했다. 그러나 변경에 유연하면서 확장하기 쉬운 애플리케이션 아키텍처의 구축이 어려워지면서 프레임워크가 등장한다.

CBD(component based development)방법론을 기반으로 하는 SPA(single page application)가 대중화되면서 다양한 SPA 프레임워크/라이브러리가 많은 사용층을 확보중이다.

> SPA의 예: Angular, React, Vue.js, Svelte



#### 2.4 자바스크립트와 ECMAScript



ECMAScript는 자바스크립트의 포준 사양인 ECMA-262를 말하며  프로그래밍 언어의 핵심 문법을 규정한다. 각 브라우저 제조사는 ECMAScript 사양을 준수해서 브라우저에 내장되는 자바스크립트 엔진을 구현한다.

자바스크립트는 기본뼈대인 ECMAScript와 브라우저가 별도로 지원하는 클라이언트 사이드 Web API, 즉 DOM, BOM, Canvas, XMLHttpRequest, fetch, requestAnimationFrame, SVG, Web Storage, Web Component, Web Worker 등을 아우르는 개념이다.

클라이언트 사이드 Web API는 월드 와이드 웹 콘소시엄에서 별도의 사양으로 관리하고 있다. [링크](https://developer.mozilla.org/ko/docs/Web/API)

#### 2.5 자바스크립트의 특징

자바스크립트는 웹 브라우저에서 동작하는 유일한 프로그래밍언어로, 기본 문법은 C, 자바와 유사하고 Self에서는 프로토타입 기반 상속을, Scheme에서는 함수의 개념을 차용했다.

자바스크립트는 인터프리터 언어다.

---

##### 인터프리터 언어 vs 컴파일러 언어

|                     컴파일러 언어                     |                       인터프리터 언어                        |
| :---------------------------------------------------: | :----------------------------------------------------------: |
| 컴파일 타임에 소스코드 전체를 머신코드로 변환 후 실행 | 런타임에 문 단위로 한 줄씩 중간 코드인 바이트코드로 변환 후 실행 |
|                    실행 파일 생성                     |                     실행 파일 생성 안함                      |
|        펌파일 단계와 실행 단계가 분리되어있음         |           한줄씩 바이트코드로 변환하고 바로 실행함           |
|               컴파일은 단 한번 수행된다               |                   실행될 때마다 인터프리트                   |
|     컴파일과 실행단계가 분리되어 실행 속도가 빠름     |        인터프리트와 실행이 반복수행되므로 비교적 느림        |

그러나 대부분의 모던 브라우저에서는 명시적인 컴파일 단계를 거치지는 않지만 복잡한 과정을 거치며 일부 소스코드를 컴파일하고 실행한다. 그러나 인터프리터의 도움없이 실행이 안되므로 컴파일러 언어는 아니다.

자바스크립트는 명령형, 함수형, 프로토타입 기반 객체지향 프로그래밍을 지원하는 **멀티 패러다임 프로그래밍 언어**다.

클래스, 상속, 정보 은닉을 위한 키워드가 없어서 객체지향 언어가 아니라는 논쟁이 있지만 자바스크립트는 클래스 기반 객체지향 언어보다 효율적이면서 강력한 프로토타입 기반의 객체지향 언어다.



### 4.변수

컴퓨터는  CPU를 사용해 연산하고, 메모리를 사용해 데이터를 기억한다.

메모리는 데이터를 저장할 수 있는 메모리 셀의 집합체다. 메모리 셀 하나의 크기는 1바이트(8비트)이며, 컴퓨터는 메모리 셀의 크기, 즉 1바이트 단위로 데이터를 저장하거나 읽어들인다.

각 셀은 고유의 메모리 주소를 갖는다. 이 메모리 주소는 메모리 공간의 위치를 나타내며, 0부터 시작해 메모리의 크기만큼 정수로 표현된다.

```js
10 + 20
```

위의 연산을 한다고 가정해보자. 

연산이 끝나면 연산 결과는 메모리에 저장되지만 그 결과를 재사용할 수 없는 상태이다. 결과가 저장된 메모리에 직접 접근하는 수밖에 없다. 하지만 메모리 주소를 통해 값에 직접 접근하는 것은 치명적인 오류를 발생시킬 수 있어 자바스크립트는 직접적인 메모리 제어를 허용하지 않는다. 

게다가 값이 저장될 때마다 메모리의 상황에 따라서 임의의 주소에 저장이 되니 주소를 알 수도 없다.

그래서 **변수**라는 걸 활용한다. 변수는 하나의 값을 저장하기 위해 확보한 모모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름을 말한다. **값의 위치를 가리키는 상징적인 이름**이다. 이를 통해 개발자는 안전히 값에 접근할 수 있다.

``` js
const result = 10 + 20;
```

메모리 공간에 저장된 값을 식별할 수 있는 고유한 이름을 **변수이름**(변수명) 이라고 한다. 그리고 변수에 저장된 값을 **변수 값**이라고 한다. 변수에 값을 대입하는 것을 **할당**(대입, 저장, assignment)이라 하고 변수에 저장된 값을 읽어들이는 것을 **참조**(reference)라고 한다.



#### 4.2 식별자

변수 이름을 **식별자**(identifier)라고도 한다. **어떤 값을 구별해서 식별할 수 있는 고유한 이름**이라는 뜻이다.

식별자는 값이 저장되어 있는 메모리 주소와 매핑 관계를 맺으며, 이 매핑 정보도 메모리에 저장된다. 즉 **식별자는 값이 아니라 메모리 주소를 기억하고 있다.**

식별자라는 용어는 변수 이름에만 국한되어 사용되는 것이 아니라, 변수, 함수, 클래스 등의 이름들은 모두 식별자다. **메모리 상에 존재하는 어떤 값을 식별할 수 있는 이름은 모두 식별자라고 부르는 것**이다.



#### 4.3 변수선언

변수 선언(variation declaration)이란 변수를 생성하는 것을 말한다. 값을 저장키 위한 메모리 공간은 확보(allocate)하고 변수 이름과 확보된 메모리 공간은 화보가 해제(release)되기 전까지는 누구도 확보된 메모리 공간을 사용할 수 없도록 보호되므로 안전히 사용할 수 있다.

변수 선언에는 `var`,`const`,`let` 키워드를 사용한다. 

- 키워드: 자바스크립트 엔진이 수행할 동작을 규정한 일종의 명령어다.

> `var` 의 단점 : 블록 레벨 스코프를 지원하지 않고 함수 레벨 스코프를 지원한다는 것이다. 이로 인해 의도치 않게 전역 변수가 선언되어 부작용이 생기기도 한다.



자바스크립트 엔진은 변수 선언을 다음과 같은 2단계에 거쳐 수행한다.

1. 선언단계: 변수명을 등록해서 자바스크립트 엔진에 변수의 존재를 알림.
2. 초기화단계: 메모리 공간을 확보하고 암묵적으로 undefined를 할당해 초기화한다.

- undefined: 자바스크립트에서 제공하는 원시타입의 값

  

> 변수 이름을 비롯한 모든 식별자는 실행 컨텍스트에 등록된다. 실행 컨텍스트(execution context)는 자바스크립트 엔진이 소스코드를 평가하고 실행하기 위해 필요한 환경을 제공하고 코드의 실행 결과를 실제로 관리하는 영역이다.



초기화(initialization)란 변수가 선언된 이후 최초로 값을 할당하는 것을 말한다. 만약 초기화 단계를 거치지 않으면 확보된 메모리 공간에는 이전에 다른 애플리케이션이 사용했던 값이 남아있을 수 있다. 이를 쓰레기 값(garbage value)이라 한다. 따라서 메모리 공간을 확보한 다음, 값을 할당하지 않은 상태에서 곧바로 변수 값을 참조하면 쓰레기 값이 나올 수 있지만 자바스크립트의  `var` 키워드는 암묵적으로 초기화를 수행하므로 이런 위험으로부터 안전하다.



만일 선언하지 않은 식별자에 접근하면 ReferenceError(참조 에러)가 발생한다. 



#### 4.4 변수 선언의 실행 시점과 변수 호이스팅

변수 선언문이 변수를 참조하는 코드보다 뒤에 있어도, 자바스크립트 코드가 실행되면 해당 변수의 참조 에러가 발생하지 않는다. 대신 참조된 변수값은 undefined이다.

원인은 자바스크립트 엔진의 작동 방식에 있다. **자바스크립트 엔진은 런타임 이전 소스코드의 평가 과정에서 모든 선언문을 먼저 실행**한다. 이후 평가가 끝나고 나서야 선언문을 제외한 모든 소스코드를 한 줄씩 순차적으로 실행한다.

이처럼 변수 선언문이 코드의 선두로 `끌어 올려진 것`처럼 동작하는 자바스크립트 고유의 특징을 **변수 호이스팅**이라고 한다.



#### 4.5 값의 할당

변수에 값을 할당(대입, 저장, assignment) 할 때는 할당 연산자 `=` 를 사용한다. 우변의 값을 좌변의 변수에 할당한다.

```js
var score;// 변수의 선언
score = 80;// 값의 할당
```

대부분 이를 아래와 같이 한줄로 단축해서 사용한다.

```js
var score = 80;
```

단축해서 사용해도 자바스크립트 엔진은 해당 문을 2개의 문으로 나누어 각각 실행한다.

주의할 점은 변수 선언과 할당의 실행 시점이 다르다는 것이다. 변수 선언은 런타임 이전에, 값의 할당은 런타임에 실행된다.



#### 4.6 값의 재할당

재할당이란 이미 값이 할당되어 있는 변수에 새로운 값을 다시 할당하는 것을 말한다. `var` 에는 재할당이 가능한데 var키워드로 선언한 변수는 선언과 동시에 undefined로 초기화되기 때문에 엄밀히 말하자면 처음에 할당할 때부터 재할당인 셈이다.

>  재할당이 가능하기 때문에 변수라고 부르는 것이고, 재할당이 되지 않는 것은 상수라고 부른다. 

 

재할당이 되면 원래의 메모리 공간을 지우고 새로 값을 저장하는 것이 아니라, 새로운 메모리 공간을 확보하고 그 메모리 공간에 새 값을 저장한다.

메모리에는 예전에 저장된 값들이 그대로 저장되어 있고, 대신 어떤 식별자와도 매핑되어있지 않다. 이 불필요한 값들은 가비지 콜렉터에 의해서 메모리에서 자동으로 해제된다.



#### 4.7 식별자 네이밍 규칙

예약어는 식별자가 될 수 없다.

변수 선언에 별도의 주석이 필요하다면 변수의 존재목적을 명확히 드러내지 못하는 것이다.

네이밍 컨벤션의 경우 일반적으로 변수나 함수의 이름에는 카멜 케이스를 사용하고, 생성자 함수, 클래스의 이름에는 파스칼 케이스를 사용한다.



## 5장 표현식과 문

#### 5.1 값

값(value)는 식(표현식 expression)이 평가(evaluate)되어 생성된 결과를 말한다. 평가란 식을 해석해서 값을 생성하고나 참조하는 것을 의미한다.

```js
//10 + 20은 평가되어 숫자 값 30을 생성한다.
10 + 20; //30
```

모든 값은 데이터 타입을 가지며 메모리에 비트의 나열로 저장된다. 저장된 값은 데이터 타입에 따라 다르게 해석될 수 있다. 예를 들어 `0100 0001` 을 숫자로 해석하면 `65`, 문자로 해석하면 `A`가 된다.



값은 변수에 할당된다.



```js
//변수에는 10 + 20이 평가되어 생성된 숫자 값 30이 할당된다.
var sum = 10 + 20;
```

`sum` 변수에 할당되는 것은 `10 + 20`이 아니라 `10 + 20`이 평가된 값인 `30` 이다. 따라서 `10 + 20` 은 할당 이전에 평가되어 값을 생성해야 한다.

 값은 다양한 방법으로 생성할 수 있다.



#### 5.2 리터럴

리터럴(literal)은 **사람이 이해할 수 있는 문자 또는 약속된 기호를 사용해 값을 생성하는 표기법**(notation)을 말한다.



```js
//숫자 리터럴 3
3	
```

여기서 3은 단순한 아라비아 숫자가 아닌 숫자 리터럴이다. 사람이 이해할 수 있는 아라비아 숫자를 사용해 숫자 리터럴3을 코드에 기술하면 자바스크립트 엔진은 이를 평가해 숫자 값 3을 생성한다.

자바스크립트 엔진은 런타임에 리터럴을 평가해 값을 생성한다.



| 리터럴                                 | 예시                             | 비고      |
| -------------------------------------- | -------------------------------- | --------- |
| 정수 리터럴(Decimal)                   | 100                              |           |
| 부동소수점 리터럴(Floating number)     | 10.5                             |           |
| 2진수 리터럴(Binary)                   | 0b01000001                       | 0b로 시작 |
| 8진수 리터럴(Octal)                    | 0o101                            | 0o로 시작 |
| 16진수 리터럴(Hexadecimal)             | 0x41                             | 0x로 시작 |
| 문자열 리터럴(String)                  | 'Hello'<br />"World"             |           |
| 불리언 리터럴(Boolean)                 | true<br />false                  |           |
| null 리터럴                            | null                             |           |
| undefined 리터럴                       | undefined                        |           |
| 객체 리터럴(Object)                    | { name: 'Lee', address: 'Seoul'} |           |
| 배열 리터럴(Array)                     | [ 1, 2, 3 ]                      |           |
| 함수 리터럴(Function)                  | function(){}                     |           |
| 정규 표현식 리터럴(Regular expression) | /[A-Z]+/g                        |           |



#### 5.3 표현식

표현식(expression)은 값으로 평가될 수 있는 문(statement)이다. 즉, 표현식이 평가되면 새로운 값을 생성하거나 기존값을 참조한다.

리터럴은 값으로 평가되므로 리터럴도 표현식이다.

변수 식별자를 참조하면 변수값으로 평가된다. 식별자 참조는 값을 생성하지는 않지만 값으로 평가되므로 표현식이다.

즉, **값으로 평가될 수 있는 문은 모두 표현식**이다.

표현식과 값은 동치이며, 표현식을 값처럼 사용할 수 있다. 값이 위치할 수 있는 자리에는 표현식도 위치할 수 있다는 것을 의미한다.



#### 5.4 문

**문(statement)은 프로그램을 구성하는 기본 단위이자 최소 실행 단위**다. 문의 집합이 프로그램이며, 문을 작성하고 나열하는 것이 프로그래밍이다.

문은 여러 토큰으로 구성된다. **토큰(token)이란 문법적인 의미를 가지며, 문법적으로 더 이상 나눌 수 없는 코드의 기본 요소를 의미한다.** 예를 들어 키워드, 식별자, 연산자, 리터럴, 세미콜론이나 마침표 등의 기호들은 모두 토큰이다.

문을 명령문이라고도 부른다.

문은 선언문, 할당문, 조건문, 반복문 등으로 구분할 수 있다. 

#### 5.5 세미콜론과 세미콜론 자동 삽입 기능

세미콜론은 문의 종료를 나타낸다. 코드 블록 뒤에는 세미콜론을 붙이지 않는다. 코드 블록은 자체 종결성을 갖고 있기 때문이다.

세미콜론을 붙이는 것은 옵션이다. 생략이 가능하며 자바스크립트 엔진이 소스코드를 해석할 때 문의 끝이라고 예측되는 지점에 세미콜론을 자동으로 붙여주는 세미콜론 자동 삽입 기능(ASI:automatic semicolon insertion)이 암묵적으로 수행되기 때문이다.



#### 5.6 표현식인 문과 표현식이 아닌 문

값으로 표현될 수 있는 문은 모두 표현식이다.

변수에 할당해 보았을 때, 에러가 나지 않으면 표현식이고, 아니면 표현식이 아닌 것이다.

```js
var x; // 변수 선언문은 표현식이 아닌 문이다.
x= 100; 할당문은 그 자체가 표현식이지만 완전한 문이기도 하다.
```



사족1:

(잘 이해되지는 않지만 그냥 외워버렸다. 값으로 표현되면 표현식이다. 다만 궁금한 것은 사실 var x;라고 변수를 선언하면 자바스크립트 엔진이 일단 undefined를 값으로 할당한다고 하지 않았나..? 그렇다면 원칙적으로 undefined도 값이라고 본다면 표현식 아닌가? 이런 생각을 했다.)

사족2:

>  undefined는 완료값이라고 하는데, 이는 표현식의 평가 결과가 아니다. 따라서 다른 값과 같이 변수에 할당할 수 없고 참조할 수도 없다.

라고 한다.

#### 6 데이터 타입

데이터 타입이란 값의 종류를 말한다.

ES6은 7개의 데이터 타입을 제공한다. 

| 구분     | 데이터 타입       | 설명                                                |
| -------- | ----------------- | --------------------------------------------------- |
| 원시타입 | 숫자타입 (number) | 숫자, 정수와 실수 구분 없이 하나의 숫자 타입만 존재 |
|          | 문자열타입        | 문자열                                              |
|          | 불리언타입        | 논리적 참(true)과 거짓(false)                       |
|          | Undefined 타입    | Var 키워드로 선언된 변수에 암묵적으로 할당되는 값   |
|          | Null 타입         | 값이 없다는 것을 의도적으로 명시할 때 사용하는 값   |
|          | 심벌타입          | ES6에서 추가된 7번째 타입                           |
| 객체타입 |                   | 객체, 함수, 배열 등                                 |



#### 6.1 숫자타입

C나 자바의 경우 정수와 실수를 구분해서 int, ling,float, double 등과 같은 다양한 숫자 타입을 제공한다. 하지만 자바스크립트는 독특하게 하나의 숫자 타입만 존재한다.

ECMAScript 사양에 따르면 [배정밀도 64비트 부동소수점](https://262.ecma-international.org/11.0/#sec-ecmascript-language-types-number-type) 형식을 따른다.

모든 수를 실수로 처리하며 정수만 표현하기 위한 데이터 타입이 별도로 존재하지 않는다. 2진수, 8진수, 16진수를 표현하기 위한 데이터 타입을 제공하지 않기 때문에 참조하면 모두 10진수로 해석된다.

```js
var binary = 0b0100001;
var octal = 0o101;
var hex = 0x41;
/*참조하면 다 같은 값으로 해석된다*/
console.log(binary); // 65
console.log(octal); // 65
console.log(hex); // 65
```





숫자타입은 추가적으로 세가지 특별한 값도 표현할 수 있다.

+ infinity
+ -infinity
+ NaN

```js
console.log(10 / 0); // Infinity
console.log(10 / -0); // -Infinity
console.log(1 * "String"); // NaN
```

자바스크립트는 대소문자를 구별(Case-sensitive) 하므로 NaN을 NAN, Nan, nan과 같이 표현하면 에러가 난다. 



#### 6.2

텍스트데이터를 나타내는 데 사용한다. 

항상 따옴표로 감싸야한다.

자바스크립트의 문자열은 원시타입이며 변경불가능한 값(immutable value)이다.



#### 6.3 템플릿 리터럴

#### 6.3.1 멀티라인 문자열

일반 문자열 내에서는 줄바꿈(개행)이 허용되지 않는다. 일반 문자열내에서는 백슬래시(`\`)로 시작하는 이스케이프 시퀀스를 사용해야한다. 

| 이스케이스 시퀀스 | 의미                                                         |
| ----------------- | ------------------------------------------------------------ |
| `\0`              | Null                                                         |
| `\b`              | 백스페이스                                                   |
| `\f`              | 폼 피드: 프린터로 출력할 경우 다음 페이지의 시작지점으로 이동한다 |
| `\n`              | 개행: 다음행으로 이동                                        |
| `\r`              | 개행: 커서를 처음으로 이동                                   |
| `\t`              | 탭(수평)                                                     |
| `\v`              | 탭(수직)                                                     |
| `\uXXXX`          | 유니코드                                                     |
| `\'`              | 작은따옴표                                                   |
| `\"`              | 큰따옴표                                                     |
| `\\`              | 백슬래시                                                     |

 템플릿 리터럴에서는 (백틱 사용) 이스테프 시퀀스를 쓰지 않고도 줄바꿈이 가능하고 공백도 있는 그대로 적용된다.

표현식을 삽입하려면  ${}으로 표현식을 감싼다. 이때 **표현식의 평가 결과가 문자열이 아니여도 문자열로 타입이 강제로 변환되어 삽입**된다.



(생략)



#### 6.4 불리언타입

참 거짓을 나타내는 true와 false. 조건문에서 자주 사용한다.



#### 6.5 undefined 타입



undefiened는 개발자가 쓰는 것이 아니니, 변수에 값이 없다는 것을 명시하고 싶으면 null을 쓸 것.



> 선언(declaration)과 정의(definition)
>
> 일반적으로 정의란 개념은 어떤 대상을 명확하게 규정하는 것을 의미한다. 자바스크립트의 undefined에서 말하는 정의란 변수에 값을 할당하여 변수의 실체를 명확히 하는 것을 말한다.
>
> 다른 프로그래밍 언어에서는 선언과 정의를 엄격하게 구분해서 사용하는 경우가 있다. 예를 들어, **C에서 선언과 정의는 "실제로 메모리 주소를 할당하는가"로 구분**한다. 단순히 컴파일러에게 식별자의 존재만 알리는 것은 선언이고, 실제로 컴파일러가 변수를 생성해서 식별자와 메모리 주소가 연결되면 정의로 구분한다.  **자바스크립트의 경우 변수를 선언하면 암묵적으로 정의가 이뤄지기 때문에 선언과 정의의 구분이 모호**하다.
>
> ECMAScript 사양에서 변수는 '선언한다'라고 표현하고, 함수는 '정의한다'라고 표현한다.

#### 6.6 null

null은 변수에 값이 없다는 것을 의도적으로 명시할 때 사용한다. **변수에 null을 할당하는 것은 변수가 이전에 참조하던 값을 더 이상 참조하지 않겠다는 의미다.** 이전에 할당되어 있던 값에 대한 참조를 명시적으로 제거하는 것으로, 자바스크립트는 누구도 참조하지 않는 메모리 공간에 대해 가비지 콜렉션을 수행할 것이다.



함수가 유효한 값을 반환할 수 없는 경우 명시적으로 null을 반환하기도 한다. 예를 들어, HTML 요소를 검색해 반환하는 document.querySelector 메서드는 조건에 부합하는 HTML 요소를 검색할 수 없는 경우 에러 대신 null을 반환한다.





#### 6.7 심벌 타입

심벌은 ES6에서 추가된 7번째 타입으로 변경 불가능한 원시타입의 값이다. 심벌 값은 다른 값과 중복되지 않는 유일무이한 값이다. 따라서 주로 이름이 충돌할 위험이 없는 객체의 유일한 프로퍼티 키를 만들기 위해 사용한다.

심벌 이외에 원시 값은 리터럴을 통해 생성하지만 심벌은 Symbol 함수를 호출해 생성한다. 이때 생성된 심벌 값은 외부에 노출되지 않으며, 다른 값과 절대 중복되지 않는 유일무이한 값이다. 

```js
/*심벌 값을 생성한다*/
var key = Symbol('key');

/*객체를 생성한다*/
var obj = {};

/*이름이 충돌할 위험이 없는 유일무이한 값인 심벌을 프로퍼티 키로 사용한다*/
obj[key] = 'value';
console.log(obj[key]); // value

```



사족:

(전혀 이해못했음)

#### 6.8 객체타입

자바스크립트의 데이터 타입은 크게 원시 타입과 객체 타입으로 분류한다. 이 두 타입은 근본적으로 다르다는 의미다.

중요한 것은 자바스크립트는 객체기반의 언어이며, 자바ㅡ크립트을 이루고 있는 거의 모든 것이 객체라는 것이다. 지금까지 살펴본 6가지 데이터 타입 이외의 값은 모두 객체 타입이다.



#### 6.9 데이터 타입의 필요성

#### 6.9.1 데이터 타입에 의한 메모리 공간의 확보와 참조

값은 메모리에 저장하고 참조할 수 있어야 한다. 메모리에 값을 저장하려면 먼저 확보해야할 메모리 공간의 크기를 결정해야 한다. 즉 몇 바이트의 메모리 공간을 사용해야 낭비와 손실 없이 값을 저장할 수 있는지 알아야 한다. 자바스크립트 엔진은 데이터 타입에 따라 정해진 크기의 메모리 공간을 확보한다. 

만일 `var score = 100;` 이라고 변수를 선언한다고 치자. 그러면 자바스크립트 엔진은 이를 숫자 타입의 값으로 해석하고 숫자타입의 값 100을 저장하기 위해 8바이트의 메모리 공간을 확보한다. 그리고 이를 2진수로 저장한다.

참조할 때는 score 변수가 숫자 타입임을 알고 8바이트 단위로 메모리를 읽어들인다. (그렇지 않으면 데이터가 훼손된다)

#### 6.9.2 데이터 타입에 의한 값의 해석

메모리에서 읽어들이 2진수를 어떻게 해석할까? 해석할 때도 변수의 타입에 따라서 해석한다. (2진수의 숫자는 어떻게 해석하느냐에 따라 숫자가 되기도 하고 문자열이 되기도 한다)

> 정리
>
> - 값을 저장할 때 확보해야 하는 메모리 공같의 크기를 결정하기 위해
> - 값을 참조할 때 한 번에 읽어 들여야 할 메모리 공간의 크기를 결정하기 위해
> - 메모리에서 읽어들인 2진수를 어떻게 해석할지 결정하기 위해



#### 6.10 동적 타이핑

#### 6.10.1 동적 타입 언어와 정적 타입 언어

모든 값은 데이터 타입을 가진다. 그렇다면 변수는 어떨까? C나 자바 같은 정적타입 언어는(static/strong type) 변수를 선언할 때 변수에 할당할 수 있는 값의 종류, 즉 데이터 타입을 사전에 선언해야 한다. 이를 명시적 타입선언이라 한다. 

정턱 타입 언어는 변수의타입을 변경할 수 없으며, 변수에 선언한 타입에 맞는 값만 할당할 수 있다. 정적 타입 언어는 컴파일 시점에 타입 체크(선언한 데이터 타입에 맞는 값을 할당했는지 검사하는 처리)를 수행한다. 만약 타입 체크를 통과하지 못했다면 에러를 방생시키고 프로그램의 실행 자체를 막는다. 이를 통해 타입의 일관성을 강제함으로써더욱 안정적인 코드의 구현을 통해 런타임에 발생하는 에러를 줄인다. 대표적인 정적 타입 언어로 C, C++, 자바, 코틀린, 고, 하스켈, 러스트, 스칼라 등이 있다.

자바스크립트는 정적 타입 언어와 다르게 변수를 선언할 때 타입을 선언하지 않는다.  다만 var, let, const 키워드를 사용해 변수를 선언할 뿐이다. 자바스크립트의 변수는 정적 타입 언어와 같이 미리선언한 데이터 타입의 값만 할당할 수 있는 것이 아니다. 어떠한 데이터 타입의 값이라도 자유롭게 할당할 수 있다.

 자바스크립트의 변수에는 어떤 데이터 타입의 값이라도 자유롭게 할당할 수 있으므로 정적 타입 언어에서 말하는 데이터 타입과 개념이 다르다. 정적 타입 언어는 변수 선언 시점에 변수의 타입이 결정되고 변수의 타입을 변경할 수 없다. 자바스크립트에서는 값을 할당하는 시점에 변수의 타입이 동적으로 결정되고 변수의 타입을 언제든지 자유롭게 변경할 수 있다.



다시 말해, 자바스크립트의 변수는 선언이 아닌 할당에 의해 타입이 결정(타입 추론)된다. 그리고 재할당에 의해 변수의 타입은 언제든지 동적으로 변할 수 있다. 이러한 특징을 동적 타이핑이라하며, 자바스크립트를 정적 타입 언어와 구별하기 위해 동적 타입(dynamic/weak type )언어라 한다. 대표적인 동적 타입 언어로는 자바스크립트, 파이썬, PHP, 루비, 리스브 펄 등이 있다.

처음의 질문으로 돌아가 보자. 변수는 타입을 가질까? 기본적으로 변수는 타입을 갖지 않는다. 하지만 값은 타입을 갖는다. 따라서 현재 변수에 할당되어 있는 값에 의해 변수의 타입이 동적으로 결정된다고 표현하는 것이 더 적절하다. 변수는 값에 묶여있는 값에 대한 별명이기 때문이다.



#### 6.10.2 동적 타입 언어와 변수

동적 타입 언어는 변수에 어떤 데이터 타입의 값이라도 자유롭게 할당할 수 있다. 이런 동적 타입 언어의 특징은 데이터 타입에 대해 무감각해질 정도로 편리하다는 것이다. 하지만 언제나 그렇듯 편리함의 이면에는 위험도 도사리고 있다.

모든 소프트웨어 아키텍처에는 트레이드 오프가 존재하며, 모든 애플리케이션에 적함한 은 탄환은 없듯이 동적 타입 언어 또한 구조적인 단점이 있다. 



변수 값은 언제든지 변경될 수 있기 때문에 복잡한 프로그램에서는 변화하는 변수 값을 추적하기 어려울 수 있다. 또한 동적 타입 언어의 변수는 값의 변경에 의해 타입도 언제든지 변경될 수 있다. 즉, 동적 타입언어의 변수는 값을 확인하기 전에는 타입을 확신할 수 없다.

또, 개발자의 의도와 상관없이 자바스크립트 엔진에 의해 암묵적으로 타입이 자동으로 변환되기도 한다. 즉, 숫자타입의 변수일 것이라고 예측했지만 사실은 문자열 타입의 변수일 수도 있다는 말이다. 

동적 타입언어는 유연성은 높지만 신뢰성은 떨어진다.

변수를 사용할 때 주의할 사항은 다음과 같다

+ 변수는 꼭 필요한 경우에 한해 제한적으로 사용한다. 변수 값은 재할당에 의해 언제든지 변경될 수 있다. 이로 인해 동적 타입 언어인 자바스크립트는 타입을 잘못 예측해 오류가 발생할 가능성이 크다. 
+ 변수의 유효 범위(스코프)는 최대한 좁게 만들어 변수의 부작용을 억제해야 한다. 
+ 전역 변수는 최대한 사용하지 않도록 한다. 어디서든지 참조/변경 가능한 전역 변수는 의도치 않게 값이 변경될 가능성이 높고 다른 코드에 영향을 줄 가능성도 높다. 따라서 전역 변수는 프로그램의 복잡성을 증가시키고 처리 흐름을 추적하기 어렵게 만들고, 오류가 발생할 경우 오류의 원인을 특정하기 어렵게 만든다.
+ 변수보다는 상수를 사용해 값의 변경을 억제한다.
+ 변수 이름은 변수의 목적이나 의미를 파악할 수 있도록 네이밍한다. 변수 이름쭌 아니라 모든 식별자*변수, 함수, 클래스 이름등)는 존재 이유를 파악할 수 있는 적절한 이름으로 지어야 한다. 특히 식별자의 유효 범위가 넓을 수록 명확한 이름을 명명하도록 노력하자.

코드는 오해하지 안도록 작성해야한다.



사족: 본인의 경우 아직 자바스크립트가 익숙하지 않아서인지 변수 타입이 변해서 오류 생긴 적이 엄청 많음





#### 7 연산자











